<!-- DOC
https://threejs.org/docs/index.html#manual/en/introduction/Drawing-lines
https://sbcode.net/threejs/geometry-to-buffergeometry/
-->
<html>
  <head>
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/85/three.js"></script>

    <style>
      body {
        background-color: #87CEEB;
        margin: 0px;
        overflow: hidden;
      }
    </style>

    <title>Three.js basic setup</title>
  </head>

  <body>
    <div id="textReloadPage" style="display: none"><b>Reload page to create a new 3D scene</b></div>

    <div id="beforeLoadingSceneOptions">
      Number columns facade : <select id="numberColumnsFacade">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option  value="4">4</option>
        <option value="5">5</option>
        <option selected="selected" value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
      </select>

      Rule Number Long Side : <select id="factorRuleNumberColLongSide">
        <option value="two_n_minus_one">2n - 1</option>
        <option value="two_n">2n</option>
        <option value="two_n_plus_one">2n + 1</option>
      </select>

      Height Columns (m) : <select id="heightColumn">
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option selected="selected" value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>

      <button onclick="generate3dTemple()">GENERATE 3D TEMPLE</button>
    </div>

    <script>
      // generate3dTemple()

      function generate3dTemple() {
        var scene = new THREE.Scene();
        setUp(scene);
        drawArchitecturalElements(scene);
      }

      function drawArchitecturalElements(scene) {
        var idFactorRuleNumberColSide = document.getElementById('factorRuleNumberColLongSide').value
        // ----------------------------
        var numberCol = document.getElementById('numberColumnsFacade').value;
        var heightColumn = document.getElementById('heightColumn').value;
        var distBetwCols = 5;
        var thicknessColumn = 2;
        var rangeHeightColumns = [6, 20];

        var compensatingHeightColArray = [null,null,null,null,null,null,2,1,1,0,0,-1,-1,-2,-2,-3,-3,-4,-4,-5,-5];
        var compensatingHeightCol = 0;
        compensatingHeightCol = compensatingHeightColArray[heightColumn];

        var compensatingHeightFrontonArray = [null,null,null,null,null,null,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5];
        var compensatingHeightFronton = 0;
        compensatingHeightFronton = compensatingHeightFrontonArray[heightColumn];
        // ----------------------------

        var podiumResult;
        var podiumHeight = 5;
        var columnResult;
        var lengthSide = 0;
        var widthSide = 0;

        var numberColLongSide = 0;
        var architraveHeight = 1.25
        var doricFriseHeight = 1.25
        var heightPodiumPosition = -2.5
        var heightFrontonPosition = -10
        var heightColPosition = 0;

        heightColPosition = heightColumn - heightPodiumPosition - podiumHeight - architraveHeight - doricFriseHeight + compensatingHeightCol;

        if (idFactorRuleNumberColSide == 'two_n_minus_one') {
          numberColLongSide = numberCol*2 - 1;
        } else if (idFactorRuleNumberColSide == 'two_n') {
          numberColLongSide = numberCol*2;
        } else if (idFactorRuleNumberColSide == 'two_n_plus_one') {
          numberColLongSide = numberCol*2 + 1;
        }

        // FRONT
        for (var iCol = 0; iCol < numberCol; iCol++) {
          columnResult = drawOneSideColumns(false, 'blue', heightColumn);
          scene.add(columnResult);
          columnResult.position.x = iCol*distBetwCols;
          columnResult.position.y = heightColPosition;
          if (iCol == numberCol-1) {
            if (idFactorRuleNumberColSide == 'two_n_minus_one') {
              lengthSide = iCol*distBetwCols
            } else if (idFactorRuleNumberColSide == 'two_n') {
              lengthSide = iCol*distBetwCols+distBetwCols/2
            } else if (idFactorRuleNumberColSide == 'two_n_plus_one') {
              lengthSide = iCol*distBetwCols+distBetwCols
            }
          }
        }

        // LEFT SIDE
        for (var iCol = 0; iCol < numberColLongSide; iCol++) {
          columnResult = drawOneSideColumns(false, 'green', heightColumn);
          scene.add(columnResult);
          columnResult.position.z = -iCol*distBetwCols;
          columnResult.position.y = heightColPosition;
          if (iCol == numberCol-1) {
            widthSide = iCol*distBetwCols
          }
        }

        // BACK SIDE
        for (var iCol = 0; iCol < numberCol; iCol++) {
          columnResult = drawOneSideColumns(false, 'red', heightColumn);
          scene.add(columnResult);
          columnResult.position.z = (-distBetwCols*numberColLongSide)+distBetwCols;
          columnResult.position.x = iCol*distBetwCols;
          columnResult.position.y = heightColPosition;
        }

        // RIGHT SIDE
        for (var iCol = 0; iCol < numberColLongSide; iCol++) {
          columnResult = drawOneSideColumns(false, 'white', heightColumn);
          scene.add(columnResult);
          columnResult.position.z = -iCol*distBetwCols;
          columnResult.position.x = (distBetwCols*numberCol)-distBetwCols;
          columnResult.position.y = heightColPosition;
        }

        podiumResult = drawPodium(distBetwCols*numberCol, distBetwCols*numberColLongSide, podiumHeight);
        scene.add(podiumResult);
        podiumResult.position.z = -lengthSide;
        podiumResult.position.x = widthSide/2;
        podiumResult.position.y = heightPodiumPosition;

        architraveResult = drawArchitrave(distBetwCols*numberCol, distBetwCols*numberColLongSide);
        scene.add(architraveResult);
        architraveResult.position.z = -lengthSide;
        architraveResult.position.x = widthSide/2;
        architraveResult.position.y = heightColumn;

        // TODO : Ici c'est un périptère donc 4 côtés à répliquer.
        // allMetopesNumber = parseInt(numberColLongSide)*2 + parseInt(numberCol)*2 + 2;
        shortSideMetopesNumber = (numberCol)*2 + 1;

        var triglyphLength = 1;

        // metopesNumber = metopesNumber*4; // TODO : Ici c'est un périptère donc 4 côtés à répliquer.

        doricFriseResult = drawDoricFrise(distBetwCols*numberCol, distBetwCols*numberColLongSide, shortSideMetopesNumber, triglyphLength, doricFriseHeight);
        scene.add(doricFriseResult[0]);
        doricFriseResult[0].position.z = -lengthSide;
        doricFriseResult[0].position.x = widthSide/2;
        doricFriseResult[0].position.y = heightColumn - 1;

        for (var i = 1; i <= shortSideMetopesNumber; i++) {
          scene.add(doricFriseResult[1][i]);

          doricFriseResult[1][i].position.z = 2.5; // NOMBRE MAGIQUE ?

          var totalLengthArchitrave = widthSide + thicknessColumn;

          if (i < numberCol*2 + 2) {
            if (i == 1) {
              doricFriseResult[1][i].position.x = -thicknessColumn;
            } else if (i == shortSideMetopesNumber) {
              doricFriseResult[1][i].position.x = totalLengthArchitrave;
            } else {
              doricFriseResult[1][i].position.x = distBetwCols/2*i - distBetwCols;
            }
          }

          doricFriseResult[1][i].position.y = heightColumn;
        }

        frontonResult = drawFronton(distBetwCols*numberCol, distBetwCols*numberColLongSide, podiumHeight);
        scene.add(frontonResult);
        frontonResult.position.z = -lengthSide*2 -2.5; // TODO
        frontonResult.position.x = widthSide/2;
        frontonResult.position.y = -heightFrontonPosition*2 + compensatingHeightFronton;

      }

      function drawOneSideColumns(angleRotation = false, color = 'lightgoldenrodyellow', heightColumn = 10)
      {
        var columnModel = new THREE.CylinderGeometry( 1, 0.8, heightColumn, 12 );
        var material = new THREE.MeshStandardMaterial({color: color});
        var cylinder = new THREE.Mesh(columnModel, material);
        if (angleRotation !== true) {
          cylinder.rotation.z = Math.PI / 2;
          cylinder.rotation.y = Math.PI / 2;
          cylinder.rotation.x = Math.PI / 2;
        }
        return cylinder;
      }

      function drawPodium(sizePodiumLength = 20, sizePodiumWidth = 20, podiumHeight = 5)
      {
        var podiumModel = new THREE.BoxGeometry( sizePodiumLength, podiumHeight, sizePodiumWidth, 12 );
        var material = new THREE.MeshStandardMaterial({color: 'lightgoldenrodyellow'});
        var box = new THREE.Mesh(podiumModel, material);
        return box;
      }

      function drawArchitrave(sizeArchitraveLength = 20, sizeArchitraveWidth = 20, architraveHeight = 1.25)
      {
        var architraveModel = new THREE.BoxGeometry( sizeArchitraveLength, architraveHeight, sizeArchitraveWidth, 12 );
        var material = new THREE.MeshStandardMaterial({color: 'lightgoldenrodyellow'});
        var box = new THREE.Mesh(architraveModel, material);
        return box;
      }

      function drawDoricFrise(sizeDoricFriseLength = 20, sizeDoricFriseWidth = 20, metopesNumber, triglyphLength = 1, doricFriseHeight = 1.25)
      {
        var doricFriseModel = new THREE.BoxGeometry( sizeDoricFriseLength, doricFriseHeight, sizeDoricFriseWidth, 12 );
        var material = new THREE.MeshStandardMaterial({color: 'lightgoldenrodyellow'});
        var box1 = new THREE.Mesh(doricFriseModel, material);

        var box2 = []
        var triglypheModel;
        var material;
        for (var numCol = 1; numCol <= metopesNumber; numCol++) {
          triglypheModel = new THREE.BoxGeometry( triglyphLength, 1.25, triglypheWidth = 0.3, 10 );
          material = new THREE.MeshStandardMaterial({color: 'red'});
          box2[numCol] = new THREE.Mesh(triglypheModel, material);
        }
        return [box1, box2];
      }

      function drawFronton(sizeFrontonLength = 20, sizeFrontonWidth = 20, frontonHeight = 5) {
        var triangleShape = new THREE.Shape();
        var baseValueShapeTriangle = 16;
        var heightTriangle = -12;
        triangleShape.moveTo(-baseValueShapeTriangle, -baseValueShapeTriangle);
        triangleShape.lineTo(0, heightTriangle);
        triangleShape.lineTo(baseValueShapeTriangle, -baseValueShapeTriangle);
        triangleShape.lineTo(-baseValueShapeTriangle, -baseValueShapeTriangle);
        var extrudedGeometry = new THREE.ExtrudeGeometry(triangleShape, {amount: sizeFrontonWidth + 2, bevelEnabled: false});
        var extrudedMesh = new THREE.Mesh(extrudedGeometry, new THREE.MeshPhongMaterial({color: 'lightgoldenrodyellow'}));
        return extrudedMesh;
      }

      function setUp(scene) {
        document.getElementById('textReloadPage').style.display = '';
        document.getElementById('beforeLoadingSceneOptions').style.display = 'none';
        // create a WebGLRenderer and set its width and height
        var renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        // add the automatically created canvas element to the page
        document.body.appendChild( renderer.domElement );

        // create a Scene
        var onRenderFcts= [];
        scene.name = 'scene';

        // create a PerspectiveCamera
        var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 10000);
        camera.position.set( 0, 0, 100 );
        camera.fov = 30; // ZOOM
        camera.updateProjectionMatrix();
        var aspect = window.innerWidth / window.innerHeight;
        var nearClippingPlane = 0.1;
        var farClippingPlane = 1000;
        const width = 30;
        const height = 30;

        let geometry = new THREE.Geometry()
        geometry.vertices.push(new THREE.Vector3(-5, 0, 0))
        geometry.vertices.push(new THREE.Vector3(5, 0, 0))
        let line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }))


        //////////////////////////////////////////////////////////////////////////////////
        //		set 3 point lighting						//
        //////////////////////////////////////////////////////////////////////////////////
        ;(function()
        {
          // add a ambient light
          var light	= new THREE.AmbientLight( 0x020202 )
          scene.add( light )
          // add a light in front
          var light	= new THREE.DirectionalLight('white', 1)
          light.position.set(0.5, 0.5, 2)
          scene.add( light )
          // add a light behind
          var light	= new THREE.DirectionalLight('white', 0.75)
          light.position.set(-0.5, 2.5, -2)
          scene.add( light )
        })()

        scene.add( line );

        const size = 100;
        const divisions = 10;

        const gridHelper = new THREE.GridHelper( size, divisions );
        scene.add( gridHelper );

        //////////////////////////////////////////////////////////////////////////////////
        //		Camera Controls							//
        //////////////////////////////////////////////////////////////////////////////////
        var mouse	= {x : 0, y : 0}
        document.addEventListener('mousemove', function(event){
          mouse.x	= (event.clientX / window.innerWidth ) - 0.5
          mouse.y	= (event.clientY / window.innerHeight) - 0.5
        }, false)
        onRenderFcts.push(function(delta, now){
          camera.position.x += (mouse.x*99 - camera.position.x) * (delta*3)
          camera.position.y += (mouse.y*99 - camera.position.y + 1) * (delta*3)
          camera.lookAt( scene.position )
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		render the scene						//
        //////////////////////////////////////////////////////////////////////////////////
        onRenderFcts.push(function(){
          renderer.render( scene, camera );
        })

        //////////////////////////////////////////////////////////////////////////////////
        //		loop runner							//
        //////////////////////////////////////////////////////////////////////////////////
        var lastTimeMsec= null
        requestAnimationFrame(function animate(nowMsec){
          // keep looping
          requestAnimationFrame( animate );
          // measure time
          lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
          var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
          lastTimeMsec	= nowMsec
          // call each update function
          onRenderFcts.forEach(function(onRenderFct){
            onRenderFct(deltaMsec/1000, nowMsec/1000)
          })
        })
      }

    </script>
  </body>

</html>
